#堆和栈的区别
	1、堆：一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。
	2、栈：由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。

#堆栈缓存方式区别
	1、堆：存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。
	2、栈：使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放；
	
#垃圾回收，怎么判断可回收[https://blog.csdn.net/yhl_jxy/article/details/80950336]
	1、常用算法：[1]引用计数算法：给对象添加一个引用计数器，被引用时+1，引用失效时-1，计数器为0时表示对象可回收；[优：效率高、实现简单；缺：很难解决对象之间相互循环引用的问题]
								  所以主流的虚拟机里没有选用引用计数算法来管理内存的。
				 [2]可达性分析算法：通过一系列的称为"GC Roots"的对象作为起始点，从这些节点开始往下搜索，搜索所有走过的路径，称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。
									[优：更严谨；缺：实现复杂，代价大，分析过程需要GC停顿，即停顿所有Java执行线程]
									
#String、StringBuffer、StringBuilder
	1、线程安全：
		String、StringBuffer线程安全，单线程操作；[StringBuffer的append操作用了synchronized]
		StringBuiler线程不安全。
	2、执行速度
		StringBuilder > StringBuffer > String 
	3、各个特点
		3.1 String ： 值不可变，每次对String的操作都会生成新的String对象；
			示例1：String a = "a"; //假设a指向地址0x0001 
				   a = "b";//重新赋值后a指向地址0x0002，但0x0001地址中保存的"a"依旧存在，但已经不再是a所指向的,a 已经指向了其它地址.因此String的操作都是改变赋值地址而不是改变值操作。
			示例2：String firstString = "abc";
				   firstString = firstString + "1";
			这种情况下第二行代码中的第一个firstString和第二个firstString就不是同一个变量了，实质上它等价于：String secondString = firstString + "1"; //系统内部又新建了一个String的类型，虽然他表面上名字没变，所以这就是他慢的原因
		3.2 StringBuffer :

#进程与线程[https://blog.csdn.net/ooppookid/article/details/51468995]
	进程是资源分配的最小单位，线程是cpu调度的最小单位[资源分配的最小单位是进程，而cpu调度的最小单位是时间片！]
	1、进程：操作系统资源分配的最小单位，拥有自己独立的地址空间，当操作系统创建一个进程后，该进程会自动申请一个名为主线程（首要线程）的线程。
	2、线程：程序执行的最小单位	，没有地址空间，线程包含在进程的地址空间中。线程上下文只包含一个堆栈、一个寄存器、一个优先权，线程文本包含在他的进程 的文本片段中，进程拥有的所有资源都属于线程。
	3、联系与区别：
		3.1 调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位；
		3.2 并发：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行；
		3.3 资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源；
		3.4 系统开销 ：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。
# 测试git